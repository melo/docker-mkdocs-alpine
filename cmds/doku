#!/usr/bin/perl
#
# All around crazy stuff...
#

use strict;
use warnings;
use Path::Tiny;
use JSON::MaybeXS;
use MIME::Types;
use Getopt::Long;
use Data::Dumper;
use YAML::XS;


#######################################
### Good old usage...

sub usage {
  my $ec = 1;
  $ec = ${ shift() } if ref($_[0]) eq 'SCALAR';

  print <<EOU;
Usage: doku <path_to_wiki> [<build_path>]

  The <path_to_wiki> must be a directory with a docs/
  subdirectory where the files are stored.

  If <build_path> is present, it will be created, with
  a db.json file at the root. A docs/ subfolder will
  contain the duplicate of the <path_to_wiki> with
  all the magic applied.


Options:

  --help,-?   this message
  --debug     enable extensive debug information

EOU

  print "FATAL: @_\n" if @_;
  exit($ec);
}


#######################################
### Parse those options, validate those parameters

my %opts;
GetOptions(\%opts, 'help|?', 'debug') or usage();
usage(\0) if $opts{help};
$ENV{DEBUG} = 1 if $opts{debug};

my ($wiki, $output_path) = map { path($_) } @ARGV;
usage('requires a source directory') unless $wiki and $wiki->is_dir;


#######################################
### We are good to go...

# Make this a gloabal, for performance/caching reasons
our $mdb = MIME::Types->new;

# Do our dance...
my $db = parse_wiki($wiki);

my $ns = $db->{notices} ||= [];
if (@$ns) {
  print "\nNotices detected:\n";
  print " . " . uc($_->[0]) . ": $_->[2]\n" for @$ns;
}

build_wiki($output_path, $db);
exit(0);


#######################################
### Build phases - parsing

sub parse_wiki {
  my ($wiki) = @_;

  my $docs = $wiki->child('docs');
  my %db   = (
    root    => $wiki,
    docroot => $docs,
    objs    => {},
    notices => [],
    files   => {
      all     => [],
      skipped => [],
      rewrite => [],
      copy    => [],
      cfg     => [],
    },
  );

  ## Keep track of wiki metadata files, they will be copied over
  ## to the output folder
  $db{files}{cfg} = _collect_wiki_cfg_files(\%db);

  ## Make sure docroot is a object too
  # this makes it easier to "list" all folders and have the docroot there too
  # on the other hand, we need to deal with 'path' == '.' on some places...
  my $meta = extract_meta_from_folder($docs, \%db);
  _idx_meta(\%db, $docs, $meta);

  ## Scan the entire wiki and index it
  my $i = $docs->iterator({ recurse => 1 });
  while (my $f = $i->()) {
    if ($f->is_file) { $meta = extract_meta_from_file($f, \%db) }
    elsif ($f->is_dir) { $meta = extract_meta_from_folder($f, \%db) }
    else               { trace(" ignoring file $f, could not determine type"); next }    ## wtf??? notice?

    _idx_meta(\%db, $f, $meta);
  }

  return \%db;
}

sub _idx_meta {
  my ($db, $f, $meta) = @_;

  my $docs = $db->{docroot};
  my $rf   = $f->relative($docs);

  if ($meta->{file_idx}) {
    ## Keep track of all files we find, with their ID's, we have multiple files
    push @{ $db->{files}{all} }, $rf;

    if    ($meta->{skip})    { push @{ $db->{files}{skipped} }, $rf }
    elsif ($meta->{rewrite}) { push @{ $db->{files}{rewrite} }, $rf }
    else                     { push @{ $db->{files}{copy} },    $rf }
  }

  ## Keep track of all found objects to our DB
  for my $obj (@{ $meta->{objs} }) {
    my $uid = $obj->{uid};

    if (my $prev = $db->{objs}{$uid}) {
      push @{ $db->{notices} },
        [error => $f, "object '$uid' found in $f was previously declared at $prev->{file}, line $prev->{line}"];
      next;
    }

    $db->{objs}{$uid} = $obj;
  }

  return;
}

sub _collect_wiki_cfg_files {
  my ($db) = @_;
  my $wiki = $db->{root};

  my @cfg_files;
  my $iter = $wiki->iterator;    ## Not recursive...
  while (my $f = $iter->()) {
    next if $f->basename eq 'docs';    ## Skip docroot
    push @cfg_files, $f->basename;
  }

  return \@cfg_files;
}


#######################################
### Build phase

sub build_wiki {
  my ($output_path, $db) = @_;
  return unless $output_path;

  ## Don't generate nothing if we have errors, warnings are ok
  die "FATAL: skipping wiki building, errors detected\n" if grep { $_->[0] eq 'error' } @{ $db->{notices} };

  debug(\"", "Build output wiki");

  my $docroot = $output_path->child('docs');
  $docroot->mkpath;

  ## calculate docroot-relative src and dst files for a object
  my $doc_src_dest = sub {
    my $src  = $db->{docroot}->child($_[0]);
    my $dest = $docroot->child($_[0]);
    $dest->parent->mkpath;
    return ($src, $dest);
  };

  ## calculate wiki-relative src and dst files for a object
  my $root_src_dest = sub {
    my $src  = $db->{root}->child($_[0]);
    my $dest = $output_path->child($_[0]);
    return ($src, $dest);
  };

  ## Rewrite documents
  for my $f (@{ $db->{files}{rewrite} }) {
    my ($src, $dest) = $doc_src_dest->($f);
    trace("rewrite '$f': from '$src' to '$dest'");
    rewrite_file($f, $db, $src, $dest);
  }

  if ($output_path ne $db->{root}) {
    ## Copy over other files
    for my $f (@{ $db->{files}{copy} }) {
      my ($src, $dest) = $doc_src_dest->($f);
      trace("copy '$src' to '$dest'");
      $src->copy($dest);
    }

    ## Copy over our config files
    for my $f (@{ $db->{files}{cfg} }) {
      my ($src, $dest) = $root_src_dest->($f);
      trace("copy '$src' to '$dest'");
      $src->copy($dest);
    }
  }

  mkdocs_update_pages($output_path, $db);    ## will only work if mkdocs.yml is present
  $output_path->child('db.json')->spew_raw(JSON::MaybeXS->new->convert_blessed->canonical->encode($db));
}


#######################################
### Generate document tree
#
# TODO: See https://github.com/lukasgeiter/mkdocs-awesome-pages-plugin
# for more ideas for the future
#
# In particular:
#  * collapsed sections is nice: if a folder only has one file, move it to the parent
#  * custom arranje orders at the folder level: use the .folder.json metadata to arrange
#    the order of the childs, very flexible
#

sub generate_page_tree {
  my ($db) = @_;

  my $root;
  my %trees;

  my $folders = db_select($db, { where => 'is_folder()' });
  for my $f (sort { length($a->{path}) <=> length($b->{path}) } @$folders) {
    my $childs = db_select(
      $db, { where => 'parent = this.path and (is_document() or is_folder())' },
      $f    ## first parameter is the "this" or "page" object
    );

    my @pages;
    for my $c (@$childs) {
      ## Decide on the title for the link
      my $title;
      if    (exists $c->{attr}{index_title}) { $title = $c->{attr}{index_title} }
      elsif (exists $c->{attr}{title})       { $title = $c->{attr}{title} }
      elsif (exists $c->{attr}{name})        { $title = $c->{attr}{name} }
      else                                   { $title = $c->{name} }

      ## Cache the sort order ID, provide a high default
      ## Elsewhere on this system, we define the defailt index_order
      my $order_id;
      if   (exists $c->{attr}{index_order}) { $order_id = $c->{attr}{index_order} }
      else                                  { $order_id = 150 }

      ## Files we store directly, but folders we keep track of the subtree
      ## to graft their own pages later
      if ($c->{type} eq 'file') {
        my $skip = exists $c->{attr}{skip_index} ? $c->{attr}{skip_index} : 0;
        push @pages, { title => $title, path => "$c->{path}", skip => $skip, order_id => $order_id };
      }
      else {
        my $entry = { title => $title, order_id => $order_id };
        push @pages, $entry;
        $trees{ $c->{uid} } = $entry;
      }
    }

    ## Sort them...
    @pages = sort { $a->{order_id} <=> $b->{order_id} || $a->{title} cmp $b->{title} } @pages;

    ## Update and nest the tree's
    if (my $subtree = delete $trees{ $f->{uid} }) {
      $subtree->{pages} = \@pages;
    }
    else {
      $root = { pages => \@pages };
    }
  }

  return $root;
}


#######################################
### MkDocs support
#
# On MkDocs there is a limitation that all files in the wiki *must* be in the 'pages'
# configuration. The 'pages' can either be empty, and in this case they will generate
# it based on their rules, or it can contain all the pages in the wiki.
#
# But we support "skip_index".
#
# This two functions will walk the tree, convert it to mkdocs.yml 'pages' format
# and will also generate the 'Other files' tree, with files that wanted to be skipped.
#
# It is a tradeoff between having all files in the 'pages' cfg, and not wanting to see
# them in the index structure.
#
# We hope this requirement will be lifted in a future version of MkDOcs, see
#
#

sub mkdocs_update_pages {
  my ($output_path, $db) = @_;

  my $cfg_path = $output_path->child('mkdocs.yml');
  if (!$cfg_path->exists) {
    debug("skipping MkDocs pages update, no '$cfg_path' found");
    return;
  }

  my $tree = generate_page_tree($db);
  $tree = _mkdocs_clean_tree($tree);

  my $cfg = Load($cfg_path->slurp_raw);
  $cfg->{pages} = $tree->{pages};

  $cfg_path->spew(Dump($cfg));

  return;
}

sub _mkdocs_clean_tree {
  my ($root) = @_;

  my ($new_pages, $skip_tree_pages) = _mkdocs_walk_tree_pages_and_cleanup($root->{pages});
  push @$new_pages, { 'Other files' => $skip_tree_pages } if $skip_tree_pages;

  return { pages => $new_pages };
}

sub _mkdocs_walk_tree_pages_and_cleanup {
  my ($current_pages) = @_;

  my @new_pages;
  my @skip_tree_pages;

  for my $c (@$current_pages) {
    my $title = $c->{title};

    if (exists $c->{pages}) {    ## This is a folder
      my $pages = $c->{pages};
      my ($folder_new_pages, $folder_skip_tree_pages) = _mkdocs_walk_tree_pages_and_cleanup($pages);

      push @new_pages, { $title => $folder_new_pages };
      push @skip_tree_pages, { $title => $folder_skip_tree_pages } if @$folder_skip_tree_pages;
    }
    else {
      if   ($c->{skip}) { push @skip_tree_pages, { $title => $c->{path} } }
      else              { push @new_pages,       { $title => $c->{path} } }
    }
  }

  return (\@new_pages, \@skip_tree_pages);
}


#######################################
### Extract metadata from files/folders

sub extract_meta_from_file {
  my ($f, $db) = @_;

  debug(\"", "Check file $f");

  my $docs = $db->{docroot};

  my $rf   = $f->relative($docs);
  my $mime = $mdb->mimeTypeOf($f->basename);
  if (!$mime) {
    push @{ $db->{notices} }, [warn => $f, "MIME type for '$f' not found"];
    $mime = 'application/x-octect-stream';
  }

  my $g_obj = {
    type      => 'file',
    id        => $rf,
    parent    => $f->parent->relative($docs),
    name      => $f->basename,
    path      => $rf,
    url       => "/$rf",
    mime_type => "$mime",
    attr      => { name => $f->basename, index_order => 100 },
  };
  $g_obj->{uid} = "$g_obj->{type}.$g_obj->{id}";

  $g_obj->{attr}{index_order} = 10 if $rf->basename eq 'index.md';

  my %meta = (objs => [$g_obj], uid => $g_obj->{uid}, file_idx => 1);
  parse_dsl($f, $db, \%meta) if is_document($g_obj);

  return \%meta;
}

sub extract_meta_from_folder {
  my ($f, $db) = @_;

  debug(\"", "Check folder $f");

  my $docs = $db->{docroot};
  my $rf   = $f->relative($docs);
  my $name = $f eq $docs ? '<root-folder>' : $f->basename;

  my $folder_obj = {
    type      => 'folder',
    id        => $rf,
    parent    => $f->parent->relative($docs),
    name      => $name,
    path      => $rf,
    mime_type => is_folder(),
    attr      => { name => $name, index_order => 50 },
  };
  $folder_obj->{uid} = "$folder_obj->{type}.$folder_obj->{id}";

  ## parse .folder.json attrs
  my $meta_file = $f->child('.folder.json');
  if ($meta_file->exists) {
    my $attrs = eval { decode_json($meta_file->slurp_raw) };
    if (ref($attrs) eq 'HASH') {
      $folder_obj->{attr} = { %{ $folder_obj->{attr} }, %$attrs };
    }
    else {
      die "FATAL: invalid folder meta file '$meta_file': " . ($@ || 'must be a object');
    }
  }

  ## See if we can have a URL
  my $index_file = $f->child('index.md');
  if ($index_file->exists) {
    $folder_obj->{url} = $rf eq '.' ? '/index.md' : "/$rf/index.md";
  }

  return { objs => [$folder_obj], uid => $folder_obj->{uid} };
}


#######################################
### Our super DSL parser

sub parse_dsl {
  my ($f, $db, $meta) = @_;

  ## All files through here will need rewrite
  $meta->{rewrite} = 1;

  ## This is our stack-based parser
  my $objs  = $meta->{objs};
  my $g_obj = $objs->[0];
  my @stack = ({ ctx => 'global', c => $g_obj }, { ctx => 'obj', c => $g_obj, end_on_empty_line => 1 });
  $meta->{seq} = \my @seq;

  ## Prepare for line-by-line parsing
  my @lines = $f->lines({ chomp => 1 });
  push @lines, \'';    ## EOF marker

  ## Start the parse...
  my $line = 0;
  while (defined(my $l = shift @lines)) {

    ## EOF handling - we allow one last loop to detect
    my $eof = ref($l) ? 1 : 0;

    ## Keep track of the top of the stack, easier access
    $line++;
    my $sp    = $stack[-1];
    my $ctx   = $sp->{ctx};
    my $c_obj = $sp->{c};
    debug(
      sprintf(
        '%4d %s/%s/%s: %s',
        $line, $ctx, $c_obj->{type},
        (exists $c_obj->{id} ? $c_obj->{id} : '<no id>'),
        ($eof                ? '<<EOF>>'    : $l)
      )
    );

    ## Helpers...
    my $keep_line = sub { push @{ $c_obj->{buf} }, [$line, $l] };
    my $keep_seq = sub { push @seq, delete $c_obj->{buf} if exists $c_obj->{buf} };
    my $pop_stack = sub {
      my $old_sp = pop @stack;
      if (my $cb = $old_sp->{wrap_cb}) {
        $cb->($old_sp->{c}, $g_obj, $f, $old_sp->{line});
      }
      return $old_sp;
    };

    ## Manage here-documents
    if ($ctx eq 'here_doc') {
      if ($eof) {
        push @{ $db->{notices} }, [error => $f, "file $f ended inside a here-doc (looking for $sp->{terminator})"];
        $pop_stack->();
        $line-- && redo;
      }

      ## Match the terminator, all was well
      if ($l =~ m/^\s*\Q$sp->{terminator}\E$/) {
        trace('found terminator');
        $c_obj->{attr}{ $sp->{field} } = $sp->{buf};
        $pop_stack->();
      }
      ## a small notice, in case we miss the terminator
      elsif ($l =~ m/^(\.\w+)/) {
        push @{ $db->{notices} },
          [warn => $f, "Found '$1' inside here doc, did you miss terminator '$sp->{terminator}' at $f line $line?"];
        trace('found dot-attr inside here-doc, possible missing terminator');
      }
      ## everything else, it is fair game
      else {
        trace('just another heredoc line');
        $sp->{buf} .= "$l\n";
      }
      next;
    }

    ## When inside a object, we only accept attrs and empty lines
    ## we drop from this ctx on the first non-matching line
    if ($ctx eq 'obj') {
      if ($eof) {
        trace('EOF, pushing last obj and empty lines, redoing');
        push @seq, $pop_stack->();
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## explicit .end...
      elsif ($l =~ m/^\s*\.end(\s+.+)?$/) {
        trace('explicit end of object');
        push @seq, $pop_stack->();
        $keep_seq->();    ## keep trailing WS if we have it
      }

      ## no nested objects!
      elsif ($l =~ m/^\s*\.def\s+/) {
        trace('another object detected, ending current one and redoing parser');
        push @seq, $pop_stack->();
        $keep_seq->();    ## keep trailing WS if we have it
        $line-- and redo; ## we need to keep the line count straight
      }

      ## empty lines
      elsif ($l =~ m/^\s*$/) {
        if ($sp->{end_on_empty_line}) {
          trace('end on empty line triggered, ending obj and redoing parse');
          push @seq, $pop_stack->();
          $line-- and redo;    ## we need to keep the line count straight
        }
        else {
          trace('keep the empty line');
          $keep_line->();
        }
      }

      ## named here-doc
      elsif ($l =~ m/^\s*\.(\w+)\s+<<(\S*?)\s*$/) {
        push @stack,
          {
          ctx        => 'here_doc',
          c          => $c_obj,
          field      => $1,
          terminator => $2 || '.end',
          line       => $line,
          };
        trace("Starting heredoc for field $stack[-1]{field} (terminator $stack[-1]{terminator})");
      }

      ## straight attr => value
      elsif ($l =~ m/^\s*\.(\w+)\s+(.+?)\s*$/) {
        $c_obj->{attr}{ lc($1) } = $2;
        delete $c_obj->{buf};    ## Drop empty lines between attrs
        trace("found value '$2' for attr '$1'");
      }

      ## simple flag attr, no value
      elsif ($l =~ m/^\s*\.(\w+)\s*$/) {
        my $new_val = ++$c_obj->{attr}{ lc($1) };
        delete $c_obj->{buf};    ## Drop empty lines between attrs
        trace("found flag attr '$1', value now '$new_val'");
      }

      ## nothing more to parse here
      else {
        trace('unparsed object line, ending && redoing parse');
        push @seq, $pop_stack->();
        $keep_seq->();           ## keep trailing WS if we have it
        $line-- and redo;        ## we need to keep the line count straight
      }

      next;
    }

    ## This is the global ctx, we keep lines and look out for objects and actions
    if ($ctx eq 'global') {
      if ($eof) {
        trace('file ends...');
        $keep_seq->();
      }

      # the first h1 header will serve as attr.title
      elsif ($l =~ m/^#\s*(.+?)(\s+#)?$/) {
        if (!$g_obj->{attr}{title}) {
          $g_obj->{attr}{title} = $1;
          trace("Found H1, title is now '$g_obj->{attr}{title}'");
        }
        $keep_line->();
      }

      ## A new object is defined
      elsif ($l =~ m/^\.def\s+(\w+)\s+(.+?)\s*$/) {
        push @$objs,
          my $c = {
          uid  => "$1.$2",
          type => $1,
          id   => $2,
          line => $line,
          file => $g_obj->{id},
          attr => { name => $2 },
          };
        push @stack, { ctx => 'obj', c => $c, line => $line };
        $keep_seq->();
        trace("new object detected $c->{uid}");
      }

      ## Index action
      elsif ($l =~ m/^\.index$/) {
        $keep_seq->();
        push @stack, {
          ctx               => 'obj',
          end_on_empty_line => 1,                  ## first empty line ends the object...
          line              => $line,
          wrap_cb           => \&wrap_index_obj,
          c                 => {
            uid    => "action.index.$g_obj->{uid}.$line",
            type   => 'action',
            action => 'index',
            file   => $g_obj->{id},
            line   => $line,
          }
        };
        trace('new index action');
      }

      ## Sequence action
      elsif ($l =~ m/^\.select$/) {
        $keep_seq->();
        push @stack, {
          ctx               => 'obj',
          end_on_empty_line => 1,                   ## first empty line ends the object...
          line              => $line,
          wrap_cb           => \&wrap_select_obj,
          c                 => {
            uid       => "action.select.$g_obj->{uid}.$line",
            type      => 'action',
            action    => 'select',
            tmpl_item => "* [{{uid}}]({{url}})\n",
            file      => $g_obj->{id},
            line      => $line,
          }
        };
        trace('new select action');
      }

      ## Unparsed command
      elsif ($l =~ m/^\./) {
        push @{ $db->{notices} }, [warn => $f, "unparsed command at $f, line $line: $l"];
        $keep_line->();
      }

      ## Fallback, just keep track of things
      else {
        trace('keep line as is');
        $keep_line->();
      }

      next;
    }
  }

  my $struct = _get_structure_from_seq(\@seq, $f, $db);
  $g_obj->{structure} = $struct;

  return;
}

sub _get_structure_from_seq {
  my ($seq, $f, $db) = @_;

  ### cleanup @seq, create the document final structure
  my @struct;
  for my $e (@$seq) {
    ## Text blocks, pass them through
    if (ref($e) eq 'ARRAY') {
      if (@struct and ref($struct[-1]) eq 'ARRAY') {    ## merge multiple sets of lines
        push @{ $struct[-1] }, @$e;
      }
      else {
        push @struct, $e;
      }
    }

    ## We have a Stack context
    elsif (exists $e->{ctx} and $e->{ctx}) {            ## a stack ctx, need to dig deeper
      if ($e->{ctx} eq 'obj') {                         ## ok, some objects are important for the structure...
        my $type = $e->{c}{type};
        if ($type eq 'action') {                        ## we keep these intact
          push @struct, $e->{c};
        }
        elsif ($type ne 'file') {                       ## other non-file objects are important for the structure
          push @struct, {                               ## Keep the reference to the object, avoids recursion later on
            uid  => $e->{c}{uid},
            type => $type,
            id   => $e->{c}{id},
          };
        }
      }
      else {
        push @{ $db->{notices} },
          [error => $f, "could not interpret a stack ctx of type '$e->{ctx}' at $f, line $e->{ctx}{line}"];
      }
    }
    else {
      push @{ $db->{notices} },
        [error => $f, "could not interpret a sequence element " . Dumper($e) . " at $f, line $e->{ctx}{line}"];
    }
  }

  return \@struct;
}


#######################################
### Rewrite files that need rewritting

sub rewrite_file {
  my ($f, $db, $src, $dest) = @_;

  my $obj       = $db->{objs}{"file.$f"};
  my $structure = $obj->{structure};

  my $cnt = '';
  for my $e (@$structure) {
    if (ref($e) eq 'ARRAY') {    ## Direct content - passthrough
      $cnt .= join("\n", (map { $_->[1] } @$e), "");
      next;
    }

    my $type = $e->{type};
    if (my $render = main->can("render_$type")) {    ## Easy object-type-specific renders :)
      $cnt .= $render->($e, $obj, $db);
    }
    else {
      trace("render not found for object $type");
    }
  }

  ## gloabal cleanups
  $cnt =~ s/^\s+#/#/sm;                              ## remove all space/lines before first markdown header
  $cnt = _tmpl_render_single($cnt, $obj);            ## one final pass to remove global markers
  $cnt = _tmpl_unescape_expressions($cnt);           ## cleanup all escaped expression markers

  $dest->spew_raw($cnt);
}


#######################################
### Action wrappers
###
### cleanup/tidy the object, the parser calls them to close the object

## action index wrapper
sub wrap_index_obj {
  my ($obj) = @_;

  ## Wrap us only once - we don't set it to 1 because we call wrap_select_obj later on
  return if $obj->{_wrapper};
  trace(" wrapping index obj $obj->{uid}");

  ## Set some defaults
  $obj->{uid}       ||= '<inline_index_object>';
  $obj->{tmpl_item} ||= "* [{{attr.name}}]({{url}}): {{attr.title || ''}}\n";
  $obj->{order_by} ||= 'num attr.order=100';    ## Order by attr.order, if not found use 100

  ## .index is a select, so wrap that too
  wrap_select_obj(@_);

  ## See if we have user-defined where - promoted from attr.where by wrap_select_obj()
  ## If yes, we bypass most of the where defaults
  my ($user_where) = _field($obj, 'where');
  my ($path)       = _field($obj, 'attr.folder');
  if ($path and $user_where) { $obj->{where} = "parent == '$path' and ($user_where)" }
  elsif ($path)        { $obj->{where} = "is_document() and parent == '$path'" }
  elsif (!$user_where) { $obj->{where} = 'is_document() and parent == this.parent and uid != this.uid' }

  return;
}

## action select wrapper
sub wrap_select_obj {
  my ($obj) = @_;

  ## Wrap us only once
  return if $obj->{_wrapper};
  $obj->{_wrapper} = 1;

  $obj->{uid} ||= '<inline_select_object>';
  trace(" wrapping select obj $obj->{uid}");

  ## Normalize some fields
  my $skip_lst = $obj->{skip};
  $skip_lst = []          unless $skip_lst;
  $skip_lst = [$skip_lst] unless ref($skip_lst) eq 'ARRAY';
  $obj->{skip} = $skip_lst;

  ## Promote custom order_by
  if (my ($order_by) = _field($obj, 'attr.order_by')) {
    $obj->{order_by} = $order_by;
  }

  ## Promote custom where
  if (my ($where) = _field($obj, 'attr.where')) {
    $obj->{where} = $where;
  }

  return;
}


#######################################
### Action renders

sub render_action {
  my ($obj, $g_obj, $db) = @_;

  my $cnt = '';

  my $action = $obj->{action};
  if (my $render = main->can("actions_render_$action")) {    ## Easy action-type-specific renders :)
    $cnt = $render->(@_);
  }
  else {
    trace("render not found for action $action");
  }

  return $cnt;
}

sub actions_render_index {
  return _select_style_render(@_);
}

## .select render
sub actions_render_select {
  return _select_style_render(@_);
}

sub _select_style_render {
  my ($obj, $g_obj, $db) = @_;
  trace("render '$obj->{action}' action at line $obj->{line}");

  return _tmpl_render_list($obj, db_select($db, $obj, $g_obj));
}


#######################################
### Render helpers

## Helper to pick out a field value from an object
sub _field {
  my ($s, $spec, $default) = @_;

  if   ($spec =~ m/^attr\.(\w+)$/) { return ($s->{attr}{$1}, 1) if exists $s->{attr}{$1} }
  else                             { return ($s->{$spec},    1) if exists $s->{$spec} }

  return ($default, -1) if defined $default;

  return;
}

## Do the sort_by clause
sub _sort_results {
  my ($obj, $results) = @_;
  my ($field, $default, $is_desc, $is_num) = _build_order_by($obj);
  return $results unless $field;

  my @sorted = map { [(_field($_, $field, $default))[0], $_] } @$results;

  if ($is_desc) {
    if ($is_num) {
      @sorted = sort { $b->[0] <=> $a->[0] } @sorted;
    }
    else {
      @sorted = sort { $b->[0] cmp $a->[0] } @sorted;
    }
  }
  else {
    if ($is_num) {
      @sorted = sort { $a->[0] <=> $b->[0] } @sorted;
    }
    else {
      @sorted = sort { $a->[0] cmp $b->[0] } @sorted;
    }
  }

  return [map { $_->[1] } @sorted];
}

## build a order by structure.
# TODO: in a future version this should generate a anon sub that would sort the input list like this:
#
#  @sorted = $anon_sub->(@unsorted_objs);
#
# Some ideas:
#
#   if   ($args) { $field = "->{args}{'$field'}" }
#   else         { $field = "->{'$field'}" }
#
#   if ($def) {
#     $field .= "|| " . ($type eq 'alpha' ? "'$def'" : "$def");
#   }
#
#   my @vars = ('$a', '$b');
#   @vars = reverse @vars if $desc eq 'desc';
#
#   my $sub = 'sub { sort { ';
#   $sub .= "($vars[0]$field) " . ($type eq 'alpha' ? ' cmp ' : ' <=> ') . "($vars[1]$field)";
#   $sub .= ' } @_ }';
#
#   trace("order_by for '$oby' ==> $sub");
#   return eval $sub;
#
sub _build_order_by {
  my ($obj) = @_;
  my $oby = $obj->{order_by};
  return unless $oby;

  trace(" order by is '$oby'");

  my $type = 'alpha';
  if ($oby =~ s/^(alpha|num)\s+//) {
    $type = $1;
  }
  trace("after type '$type', order by is '$oby'");

  my $desc = 'asc';
  if ($oby =~ s/^(asc|desc)\s+//) {
    $desc = $1;
  }
  trace("after desc '$desc', order by is '$oby'");

  my ($field, undef, $def) = $oby =~ m/^([\w\.]+)(=(.+))?$/;
  die "FATAL: failed to parse order_by clause '$oby' at $obj->{file}, line $obj->{line}\n" unless $field;

  return ($field, $def, ($desc eq 'desc'), ($type eq 'num'));
}


#######################################
#### Query engine

sub _query_parser {
  my ($query) = @_;
  my $oq = $query;

  my @tree;
  my @stack;

  my $find_tokens = sub {
    for my $sp (reverse @stack) {
      return $sp->{tokens} if exists $sp->{tokens};
    }
    return;
  };

  my $push_state = sub {
    my $s = shift;
    push @stack, { @_, state => $s };
  };

  my $push_capture_state = sub {
    my @t;
    push @stack, { state => 'capture_exp', tokens => \@t };
  };

  my $atomic_expression_ends = sub {
    my $tokens = $find_tokens->();

    my $rhs = pop @$tokens;
    my $op  = pop @$tokens;
    my $lhs = pop @$tokens;
    push @$tokens, { lhs => $lhs, op => $op, rhs => $rhs, txt => "$lhs $op $rhs->[0] '$rhs->[1]'" };
  };


  ### Start the ball rolling...
  $push_capture_state->();
  $push_state->('expression');

  while ($query or @stack) {
    my $sp     = $stack[-1];
    my $state  = $sp->{state};
    my $tokens = $find_tokens->();

    $query =~ s/^\s*//sm;    ## remove leading ws - global action

    #    print "## ===> [$state (" . @stack . ")] to match: '$query'\n";
    #    use Data::Dumper;
    #    print "#### ... " . Dumper(\@stack) . "\n";

    ## Expression parsing
    if ($state eq 'expression') {
      pop @stack;
      if ($query =~ s/^\(//) {
        $push_state->('logical_op', optional => 1);
        $push_capture_state->();
        $push_state->('match', token => ')');
        $push_state->('expression');
      }
      else {
        $push_state->('logical_op', optional => 1);
        $push_state->('right_side');
        $push_state->('operator');
        $push_state->('left_side');
      }
      next;
    }

    ## Logical operation between expressions
    if ($state eq 'logical_op') {
      pop @stack;
      if ($query =~ s/^(and|or)\b//i) {
        push @$tokens, $1;
        $push_state->('expression');
      }
      next;
    }

    ## Capture expression
    if ($state eq 'capture_exp') {
      pop @stack;
      my $parent = $find_tokens->() || \@tree;
      my $tks    = $sp->{tokens};
      my $txt    = '( ' . join(' ', map { (ref() ? $_->{txt} : $_) } @$tks) . ' )';
      push @$parent, { exp => $tks, txt => $txt };
      next;
    }

    ## Constant matching
    if ($state eq 'match') {
      my $token = $sp->{token};    ## the token to match
      if ($query =~ s/^\Q$token\E//) {
        pop @stack;
      }
      else {
        return { error => "unmatched token '$token'", ctx => $query };
      }
      next;
    }

    ## Operators
    if ($state eq 'operator') {
      if ($query =~ s/^([=!<>~]+)//g) {
        ## TODO: check for valid operators
        push @$tokens, $1;
      }
      else {
        return { error => 'could not parse operator', ctx => $query };
      }
      pop @stack;
      next;
    }

    ## Left side parsing
    if ($state eq 'left_side') {
      pop @stack;
      if ($query =~ s/^([\w\._]+)\(\)//) {    ## a boolean function
        push @$tokens, { bool => $1, txt => "bool $1()" };
        pop @stack;                           ## no need for operators
        pop @stack;                           ## ... nor right side
      }
      elsif ($query =~ s/^([\w\.]+)//) {      ## a variable
        push @$tokens, $1;
      }
      else {
        return { error => 'could not parse left_side', ctx => $query };
      }
      next;
    }

    ## Right side parsing
    if ($state eq 'right_side') {
      if ($query =~ s/^(\w+)\(\)//) {         ## functions...
        push @$tokens, [func => $1];
      }
      elsif ($query =~ s/^'(.+?)'//) {        ## single quote strings
        push @$tokens, [str => $1];
      }
      elsif ($query =~ s/^"(.+?)"//) {        ## double quote strings
        push @$tokens, [str => $1];
      }
      elsif ($query =~ s/^([-+]?\d+(\.\d+)?)//) {    ## numbers
        push @$tokens, [num => 0 + $1];
      }
      elsif ($query =~ s/^([-+]?\.\d+)//) {          ## numbers with just decimals
        push @$tokens, [num => 0 + $1];
      }
      elsif ($query =~ s/^([\w\.]+)//) {             ## tokens/strings without white-space
        push @$tokens, [token => $1];
      }
      else {
        return { error => 'could not parse right_side', ctx => $query };
      }
      pop @stack;
      $atomic_expression_ends->();
      next;
    }

    die "State '$state' unhandled";
  }

  die "WTF??? found more than one top level element??? " . Dumper(\@tree) unless @tree == 1;

  return { ok => 1, tree => $tree[0], query => $oq };
}

## Match long where conditions
sub query_match {
  my ($where, $obj, @rest) = @_;

  CORE::state $query_cache = {};

  trace(" match '$obj->{uid}' against '$where'");

  if (!exists $query_cache->{$where}) {
    my $r = _query_parser($where);

    die "FATAL: failed to parse 'where' condition '$where' at $obj->{file}, line $obj->{line}: $r->{error}"
      . ($r->{ctx} ? " (stopped at '$r->{ctx}')" : '') . "\n"
      unless $r->{ok};

    $query_cache->{$where} = $r->{tree};
    trace("   cached tree for '$where'");
  }

  return _query_eval_expression($query_cache->{$where}, $obj, @rest);
}

sub _query_eval_expression {
  my ($e, @ctx)  = @_;
  my ($o, $page) = @ctx;

  ## sequence of: expression [logical_op expression]*
  if (exists $e->{exp}) {
    my @terms = @{ $e->{exp} };
    my $r = _query_eval_expression(shift(@terms), @ctx);
    while (@terms) {
      my $op  = shift @terms;
      my $rhs = shift @terms;
      if ($op eq 'and') {
        $r = _query_eval_expression($rhs, @ctx) if $r;    ## short circuit if false
      }
      elsif ($op eq 'or') {
        $r = _query_eval_expression($rhs, @ctx) unless $r;    ## short circuit if true
      }
    }

    trace("    final: check expression '$e->{txt}' => $r");
    return $r;
  }

  ## A single expression to match
  elsif (exists $e->{lhs}) {
    trace("    check simple '$e->{txt}'");

    my ($fv, $exists) = _field($o, $e->{lhs});
    return 0 unless $exists;
    return 0 unless defined $fv;

    my $op  = $e->{op};
    my $rhs = $e->{rhs};
    my ($type, $val) = @$rhs;

    ## tokens page.* are fields from the current page
    if ($type eq 'token' and $val =~ m/^(page|this)\.(.+)/) {    #
      my $pf = $2;
      my ($pv, $exists) = _field($page, $pf);
      trace("      rewrite [$type, $val] => (exists: "
          . ($exists ? 'yes, new val ' . (defined $pv ? "'$pv'" : '<not-defined>') : 'no')
          . ")");
      return 0 unless $exists;
      return 0 unless defined $pv;
      $type = 'str';                                             ## TODO: use 'num' if it looks like a number?
      $val  = $pv;
      trace("        new rhs => [$type, $val]");
    }

    ## TODO: add support for some type => 'func's

    trace("      try match $e->{lhs} => '$fv', op '$op', rhs => [$type, $val]");

    ## Match operators =, ==, and === for those who are JS-freaks
    if ($op =~ m/^==?=?$/) {
      trace("      will match '$fv' ==/eq '$val'");
      if    ($type eq 'str') { return 1 if $fv eq $val }
      elsif ($type eq 'num') { return 1 if $fv == $val }
      else                   { die "FATAL: cannot compare '$op' to a '$type' (value '$val') (from '$e->{txt}')" }
    }

    ## Match regexp ops ~
    elsif ($op =~ m/^~~?~?$/) {
      trace("      will match '$fv' =~ m/$val/");
      if ($type eq 'str' or $type eq 'num') { return 1 if $fv =~ m/$val/ }
      else { die "FATAL: cannot compare '$op' to a '$type' (value '$val') (from '$e->{txt}')" }
    }

    ## Match operators !=, !==, and !===, and <> for math freaks
    elsif ($op =~ m/^!==?=?$/ or $op eq '<>') {
      trace("      will match '$fv' !=/ne m/$val/");
      if    ($type eq 'str') { return 1 if $fv ne $val }
      elsif ($type eq 'num') { return 1 if $fv != $val }
      else                   { die "FATAL: cannot compare '$op' to a '$type' (value '$val') (from '$e->{txt}')" }
    }
    else {
      die "FATAL: operator '$op' not recognized (from '$e->{txt}')\n";
    }

    trace("      failed simple match");
    return 0;
  }

  ## Boolean functions
  elsif (exists $e->{bool}) {
    my $fn = $e->{bool};
    trace("      match boolean function $fn()");

    if    ($fn eq 'is_document') { return is_document($o) }
    elsif ($fn eq 'is_folder')   { return is_folder($o) }

    die "FATAL: boolean function $fn() non known (from '$e->{txt}')";
  }

  ## In case someone adds another one
  die "FATAL: expression format non known: ", Dumper($e);
}


#######################################
#### Template utils

sub _tmpl_render {
  my ($obj, $body) = @_;

  my $txt = '';

  if (my $tmpl = _tmpl_get($obj, 'header')) {
    $txt .= _tmpl_render_single($tmpl, $obj);
    $txt .= "\n" if $txt;    ## Make sure there is an empty line between header and the rest
  }

  $txt .= $body;

  if (my $tmpl = _tmpl_get($obj, 'footer')) {
    $txt .= "\n" if $txt;    ## Make sure there is an empty line between rest and footer
    $txt .= _tmpl_render_single($tmpl, $obj);
  }

  return $txt;
}

sub _tmpl_render_list {
  my ($obj, $list) = @_;

  my $txt = '';

  ## If we have a "if empty" template and no results, use it and skip the rest
  if (my $tmpl = _tmpl_get($obj, 'if_empty') and !@$list) {
    return _tmpl_render_single($tmpl, $obj);
  }

  my $tmpl = _tmpl_get($obj, 'item');
  die "FATAL: render list under obj $obj->{uid} failed, no tmpl_item defined and no default" unless defined $tmpl;

  for my $r (@$list) {
    $txt .= _tmpl_render_single($tmpl, $r);
  }

  return _tmpl_render($obj, $txt);
}

sub _tmpl_render_single {
  my ($tmpl, $obj) = @_;

  $tmpl =~ s/
    \{\{   ## initial marker for expression
    (.+?)  ## capture everything inside
    \}\}   ## final marker for expression
  /
    _tmpl_repl($obj, $1)
  /gex;

  ## Raw mode
  $tmpl =~ s/
    \{\{\{   ## initial marker for expression
    (.+?)  ## capture everything inside
    \}\}\}   ## final marker for expression
  /
    _tmpl_repl($obj, $1, 1)
  /gex;

  return $tmpl;
}

sub _tmpl_unescape_expressions {
  my ($cnt) = @_;

  $cnt =~ s/
    \\\{\\\{
    (
      (.+?)
    )
    \\\}\\\}
  /{{$1}}/gx;

  return $cnt;
}

sub _tmpl_repl {
  my ($obj, $expression, $raw_mode) = @_;

  trace("expression starts as '$expression'");
  $expression =~ s/^\s+|\s+$//g;

  my $default;
  if ($expression =~ m/^(.+?)\s*\|\|\s*['"](.*?)['"]$/) {
    $default    = $2;
    $expression = $1;
  }

  trace(" after defaults parsing, expression '$expression', default "
      . (defined($default) ? "'$default'" : '<no default>'));

  my ($val, $exists) = _field($obj, $expression, $default);
  trace(" field '$expression' for $obj->{uid}: val is " . ($exists ? "'$val'" : '<not found>'));

  if ($exists) {
    return '<$expression undefined>' unless defined $val;
    return $raw_mode ? $val : _encode_html($val);
  }

  return "<$expression not found>";
}

sub _tmpl_get {
  my ($obj, $name) = @_;
  return $obj->{attr}{"tmpl_$name"} if exists $obj->{attr}{"tmpl_$name"};
  return $obj->{"tmpl_$name"} if exists $obj->{"tmpl_$name"};

  return;
}

sub _encode_html {
  my ($t) = @_;

  $t =~ s/&/&amp;/gsm;
  $t =~ s/</&lt;/gsm;
  $t =~ s/>/&gt;/gsm;

  return $t;
}


#######################################
#### MIME type matchers

sub is_document {
  CORE::state $mime_match = qr{^text/(x-)?markdown$};
  CORE::state $mime       = q{text/markdown};


  return $mime unless @_;
  return $_[0]->{type} eq 'file' && $_[0]->{mime_type} =~ m/$mime_match/ if ref $_[0];
  return $_[0] =~ m/$mime_match/;
}

sub is_folder {
  CORE::state $mime = 'x-doku/folder';

  return $mime unless @_;
  return $_[0]->{type} eq 'folder' && $_[0]->{mime_type} eq $mime if ref $_[0];
  return $_[0] eq $mime;
}


#######################################
#### DB Utils

sub db_select {
  my ($db, $select, $ctx) = @_;

  trace("Start select logic");

  wrap_select_obj($select);    ## make sure we are properly wraped

  ## Prepare our filters
  my $skip_lst = $select->{skip};

  my @results;
OBJ: for my $o (values %{ $db->{objs} }) {
    if (@$skip_lst) {
      trace("  check if object $o->{uid} is in skip-list");
      next if grep { $_ eq $o->{uid} } @$skip_lst;
      trace("          not on skip list");
    }

    if (my $w = $select->{where}) {
      my $matched = ref($w) ? query_match_simple($w, $o, $ctx, $select) : query_match($w, $o, $ctx, $select);
      next OBJ unless $matched;
    }

    trace("      all filters passed, object $o->{uid} in the result set");

    push @results, $o;
  }

  trace('  sorting results, count is ' . @results);
  my $sorted = _sort_results($select, \@results);

  return $sorted;
}


#######################################
#### Logger

sub _log {
  return unless $ENV{DEBUG};
  if (ref $_[0]) { print "\n"; shift }
  print "@_\n";
}

sub debug { _log(@_) }
sub trace { _log('    . ', @_) }
